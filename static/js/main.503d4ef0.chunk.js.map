{"version":3,"sources":["App.js","serviceWorker.js","index.js"],"names":["App","props","_this","Object","classCallCheck","this","possibleConstructorReturn","getPrototypeOf","call","fullScreenRenderer","container","React","createRef","pipeline","resolution","arguments","length","undefined","sphereSource","vtkSphereSource","newInstance","radius","thetaResolution","phiResolution","sphereMapper","vtkMapper","setInputConnection","getOutputPort","sphereActor","vtkActor","setMapper","getProperty","setColor","numberOfSegments","pointType","VtkDataTypes","FLOAT","polyDataXY","vtkPolyData","pointsXY","vtkPoints","dataType","setNumberOfPoints","pointDataXY","Float32Array","vertsXY","Uint32Array","linesXY","i","j","angle","Math","PI","cos","sin","setData","setPoints","getVerts","getLines","tubeFilterXY","vtkTubeFilter","setCapping","setNumberOfSides","setRadius","setInputData","polyDataMapperXY","tubeMapperXY","tubeActorXY","polyDataXZ","pointsXZ","pointDataXZ","vertsXZ","linesXZ","tubeFilterXZ","polyDataMapperXZ","tubeMapperXZ","tubeActorXZ","polyDataYZ","pointsYZ","pointDataYZ","vertsYZ","linesYZ","tubeFilterYZ","polyDataMapperYZ","tubeMapperYZ","tubeActorYZ","renderer","getRenderer","renderWindow","getRenderWindow","removeActor","actor","createPipeline","addActor","resetCamera","render","camera","getActiveCamera","elevation","azimuth","setInterval","rotateX","rotateZ","rotateY","window","vtkFullScreenRenderWindow","background","rootContainer","current","containerStyle","updatePipeline","prevProps","react_default","a","createElement","className","ref","href","target","rel","Component","Boolean","location","hostname","match","ReactDOM","src_App_0","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.503d4ef0.chunk.js","sourcesContent":["import React, { Component } from 'react';\nimport './App.css';\n\nimport vtkActor from 'vtk.js/Sources/Rendering/Core/Actor';\nimport vtkSphereSource from 'vtk.js/Sources/Filters/Sources/SphereSource';\nimport vtkMapper from 'vtk.js/Sources/Rendering/Core/Mapper';\nimport vtkFullScreenRenderWindow from 'vtk.js/Sources/Rendering/Misc/FullScreenRenderWindow';\nimport vtkTubeFilter from 'vtk.js/Sources/Filters/General/TubeFilter';\nimport vtkPoints from 'vtk.js/Sources/Common/Core/Points';\nimport vtkPolyData from 'vtk.js/Sources/Common/DataModel/PolyData';\nimport { VtkDataTypes } from 'vtk.js/Sources/Common/Core/DataArray/Constants';\n\nclass App extends Component {\n  constructor(props) {\n    super(props);\n\n    this.fullScreenRenderer = null;\n    this.container = React.createRef();\n    this.pipeline = null;\n  }\n\n  createPipeline(resolution = 20) {\n    const sphereSource = vtkSphereSource.newInstance({ radius: 1.5, thetaResolution: resolution, phiResolution: resolution });\n\n    const atomColorR = 0.380\n    const atomColorG = 0.855\n    const atomColorB = 0.984\n\n    const sphereMapper = vtkMapper.newInstance();\n    sphereMapper.setInputConnection(sphereSource.getOutputPort());\n\n    const sphereActor = vtkActor.newInstance();\n    sphereActor.setMapper(sphereMapper);\n    sphereActor.getProperty().setColor(atomColorR, atomColorG, atomColorB)\n\n\n    const numberOfSegments = resolution;\n    let pointType = VtkDataTypes.FLOAT;\n    const tubeRadius = 5.0;\n\n    const polyDataXY = vtkPolyData.newInstance();\n    const pointsXY = vtkPoints.newInstance({ dataType: pointType });\n    pointsXY.setNumberOfPoints(numberOfSegments + 1);\n    const pointDataXY = new Float32Array(3 * (numberOfSegments + 1));\n    const vertsXY = new Uint32Array(2 * (numberOfSegments + 1));\n    const linesXY = new Uint32Array(numberOfSegments + 2);\n    linesXY[0] = numberOfSegments + 1;\n\n    for (let i = 0; i < numberOfSegments + 1; i++) {\n      for (let j = 0; j < 3; j++) {\n        const angle = i / (numberOfSegments - 1) * 2.0 * Math.PI;\n        pointDataXY[3 * i + 0] = tubeRadius * Math.cos(angle);\n        pointDataXY[3 * i + 1] = tubeRadius * Math.sin(angle);\n        pointDataXY[3 * i + 2] = 0.0;\n      }\n      vertsXY[i] = 1;\n      vertsXY[i + 1] = i;\n      linesXY[i + 1] = i;\n    }\n    pointsXY.setData(pointDataXY);\n    polyDataXY.setPoints(pointsXY);\n    polyDataXY.getVerts().setData(vertsXY);\n    polyDataXY.getLines().setData(linesXY);\n\n    const tubeFilterXY = vtkTubeFilter.newInstance();\n    tubeFilterXY.setCapping(false);\n    tubeFilterXY.setNumberOfSides(resolution);\n    tubeFilterXY.setRadius(0.5);\n\n    tubeFilterXY.setInputData(polyDataXY);\n\n    const polyDataMapperXY = vtkMapper.newInstance();\n    polyDataMapperXY.setInputData(polyDataXY);\n\n    const polyDataActorXY = vtkActor.newInstance();\n    polyDataActorXY.setMapper(polyDataMapperXY)\n\n    const tubeMapperXY = vtkMapper.newInstance();\n    tubeMapperXY.setInputConnection(tubeFilterXY.getOutputPort());\n\n    const tubeActorXY = vtkActor.newInstance();\n    tubeActorXY.setMapper(tubeMapperXY)\n    tubeActorXY.getProperty().setColor(atomColorR, atomColorG, atomColorB)\n\n    const polyDataXZ = vtkPolyData.newInstance();\n    const pointsXZ = vtkPoints.newInstance({ dataType: pointType });\n    pointsXZ.setNumberOfPoints(numberOfSegments + 1);\n    const pointDataXZ = new Float32Array(3 * (numberOfSegments + 1));\n    const vertsXZ = new Uint32Array(2 * (numberOfSegments + 1));\n    const linesXZ = new Uint32Array(numberOfSegments + 2);\n    linesXZ[0] = numberOfSegments + 1;\n\n    for (let i = 0; i < numberOfSegments + 1; i++) {\n      for (let j = 0; j < 3; j++) {\n        const angle = i / (numberOfSegments - 1) * 2.0 * Math.PI;\n        pointDataXZ[3 * i + 0] = tubeRadius * Math.cos(angle);\n        pointDataXZ[3 * i + 1] = 0.0;\n        pointDataXZ[3 * i + 2] = tubeRadius * Math.sin(angle);\n      }\n      vertsXZ[i] = 1;\n      vertsXZ[i + 1] = i;\n      linesXZ[i + 1] = i;\n    }\n    pointsXZ.setData(pointDataXZ);\n    polyDataXZ.setPoints(pointsXZ);\n    polyDataXZ.getVerts().setData(vertsXZ);\n    polyDataXZ.getLines().setData(linesXZ);\n\n    const tubeFilterXZ = vtkTubeFilter.newInstance();\n    tubeFilterXZ.setCapping(false);\n    tubeFilterXZ.setNumberOfSides(resolution);\n    tubeFilterXZ.setRadius(0.5);\n\n    tubeFilterXZ.setInputData(polyDataXZ);\n\n    const polyDataMapperXZ = vtkMapper.newInstance();\n    polyDataMapperXZ.setInputData(polyDataXZ);\n\n    const polyDataActorXZ = vtkActor.newInstance();\n    polyDataActorXZ.setMapper(polyDataMapperXZ)\n\n    const tubeMapperXZ = vtkMapper.newInstance();\n    tubeMapperXZ.setInputConnection(tubeFilterXZ.getOutputPort());\n\n    const tubeActorXZ = vtkActor.newInstance();\n    tubeActorXZ.setMapper(tubeMapperXZ)\n    tubeActorXZ.getProperty().setColor(atomColorR, atomColorG, atomColorB)\n\n    const polyDataYZ = vtkPolyData.newInstance();\n    const pointsYZ = vtkPoints.newInstance({ dataType: pointType });\n    pointsYZ.setNumberOfPoints(numberOfSegments + 1);\n    const pointDataYZ = new Float32Array(3 * (numberOfSegments + 1));\n    const vertsYZ = new Uint32Array(2 * (numberOfSegments + 1));\n    const linesYZ = new Uint32Array(numberOfSegments + 2);\n    linesYZ[0] = numberOfSegments + 1;\n\n    for (let i = 0; i < numberOfSegments + 1; i++) {\n      for (let j = 0; j < 3; j++) {\n        const angle = i / (numberOfSegments - 1) * 2.0 * Math.PI;\n        pointDataYZ[3 * i + 0] = 0.0;\n        pointDataYZ[3 * i + 1] = tubeRadius * Math.cos(angle);\n        pointDataYZ[3 * i + 2] = tubeRadius * Math.sin(angle);\n      }\n      vertsYZ[i] = 1;\n      vertsYZ[i + 1] = i;\n      linesYZ[i + 1] = i;\n    }\n    pointsYZ.setData(pointDataYZ);\n    polyDataYZ.setPoints(pointsYZ);\n    polyDataYZ.getVerts().setData(vertsYZ);\n    polyDataYZ.getLines().setData(linesYZ);\n\n    const tubeFilterYZ = vtkTubeFilter.newInstance();\n    tubeFilterYZ.setCapping(false);\n    tubeFilterYZ.setNumberOfSides(resolution);\n    tubeFilterYZ.setRadius(0.5);\n\n    tubeFilterYZ.setInputData(polyDataYZ);\n\n    const polyDataMapperYZ = vtkMapper.newInstance();\n    polyDataMapperYZ.setInputData(polyDataYZ);\n\n    const polyDataActorYZ = vtkActor.newInstance();\n    polyDataActorYZ.setMapper(polyDataMapperYZ)\n\n    const tubeMapperYZ = vtkMapper.newInstance();\n    tubeMapperYZ.setInputConnection(tubeFilterYZ.getOutputPort());\n\n    const tubeActorYZ = vtkActor.newInstance();\n    tubeActorYZ.setMapper(tubeMapperYZ)\n    tubeActorYZ.getProperty().setColor(atomColorR, atomColorG, atomColorB)\n\n    return { sphereMapper, sphereActor, tubeActorXY, tubeMapperXY, tubeActorXZ, tubeMapperXZ, tubeActorYZ, tubeMapperYZ };\n  }\n\n  updatePipeline() {\n    const renderer = this.fullScreenRenderer.getRenderer();\n    const renderWindow = this.fullScreenRenderer.getRenderWindow();\n\n    if (this.pipeline) {\n      renderer.removeActor(this.pipeline.actor);\n      this.pipeline = null;\n    }\n\n    const resolution = this.props.resolution || 40\n    this.pipeline = this.createPipeline(resolution);\n    const pipeline = this.pipeline\n    renderer.addActor(pipeline.sphereActor);\n    renderer.addActor(pipeline.tubeActorXY);\n    renderer.addActor(pipeline.tubeActorXZ);\n    renderer.addActor(pipeline.tubeActorYZ);\n    renderer.resetCamera();\n    renderWindow.render();\n\n    const camera = renderer.getActiveCamera();\n    camera.elevation(30.)\n    camera.azimuth(30.)\n\n    setInterval(function() {\n      pipeline.tubeActorXY.rotateX(2.)\n      pipeline.tubeActorXZ.rotateZ(3.)\n      pipeline.tubeActorYZ.rotateY(5.)\n      renderWindow.render();\n    }, 100)\n\n    window.pipeline = this.pipeline;\n\n    renderWindow.render();\n  }\n\n  componentDidMount() {\n    this.fullScreenRenderer = vtkFullScreenRenderWindow.newInstance({\n      background: [0.157, 0.172, 0.204],\n      rootContainer: this.container.current,\n      containerStyle: {},\n    });\n    this.updatePipeline();\n  }\n\n  componentDidUpdate(prevProps) {\n    if (prevProps.resolution !== this.props.resolution) {\n      this.updatePipeline();\n    }\n  }\n\n  render() {\n    return (\n      <div className=\"App\">\n        <header className=\"App-header\">\n          <div ref={this.container} />\n          <p>\n            Edit <code>src/App.js</code> and save to reload.\n          </p>\n          <a\n            className=\"App-link\"\n            href=\"https://kitware.github.io/vtk-js/docs/\"\n            target=\"_blank\"\n            rel=\"noopener noreferrer\"\n          >\n            Learn vtk.js\n          </a>\n          <a\n            className=\"App-link\"\n            href=\"https://reactjs.org\"\n            target=\"_blank\"\n            rel=\"noopener noreferrer\"\n          >\n            Learn React\n          </a>\n          <a\n            className=\"App-link\"\n            href=\"https://github.com/sharegate/craco\"\n            target=\"_blank\"\n            rel=\"noopener noreferrer\"\n          >\n            Learn craco\n          </a>\n        </header>\n      </div>\n    );\n  }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}